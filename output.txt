#!/usr/bin/env python3
"""
Integrated Trading System with Telegram Bot
Addresses authentication race conditions, duplicate token issues, and Telegram bot integration
Generated on: 2025-09-10
"""

import os
import sys
import json
import time
import logging
from logging.handlers import RotatingFileHandler
import threading
from datetime import datetime, time as dt_time, timedelta
import argparse
from pathlib import Path
import pytz
import schedule
import requests
import urllib3
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import traceback

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Import dependencies
try:
    from sensex_trading_bot_live import SensexTradingBot
except ImportError:
    print("Warning: sensex_trading_bot_live not found. Trading functionality will be limited.")
    SensexTradingBot = None

try:
    from kiteconnect import KiteConnect
    from kiteconnect.exceptions import (
        NetworkException, TokenException, PermissionException, 
        OrderException, InputException, DataException, GeneralException
    )
except ImportError:
    print("Warning: kiteconnect not found. API functionality will be limited.")
    KiteConnect = None
    NetworkException = TokenException = PermissionException = Exception
    OrderException = InputException = DataException = GeneralException = Exception


class AuthenticationMode(Enum):
    INTERACTIVE = "interactive"
    SCHEDULED = "scheduled"
    MANUAL = "manual"


class TradingMode(Enum):
    TEST = "test"
    LIVE = "live"


@dataclass
class AuthenticationResult:
    success: bool
    token: Optional[str] = None
    error_message: Optional[str] = None
    source: Optional[str] = None


@dataclass
class MarketStatus:
    is_trading_day: bool
    is_trading_hours: bool
    status_message: str
    current_time: datetime


@dataclass
class SystemHealth:
    postback_server_running: bool
    postback_server_url: Optional[str]
    market_status: MarketStatus
    has_token: bool
    token_preview: Optional[str]
    trading_bot_initialized: bool
    telegram_bot_running: bool
    holidays_configured: List[str]


class ISTFormatter(logging.Formatter):
    def converter(self, timestamp):
        dt = datetime.fromtimestamp(timestamp)
        return pytz.timezone('Asia/Kolkata').localize(dt).timetuple()


class ConfigurationManager:
    """Handles configuration loading and validation"""
    
    def __init__(self, config_path: str = 'config.json'):
        self.config_path = config_path
        self.config = self._load_config()
    
    def _load_config(self) -> Dict:
        """Load configuration from file with defaults"""
        defaults = {
            'use_https': True,
            'postback_urls': {
                "primary": "https://sensexbot.ddns.net/postback",
                "secondary": "https://sensexbot.ddns.net/redirect"
            },
            'server_host': 'sensexbot.ddns.net',
            'auth_timeout_seconds': 300,
            'market_holidays': [
                "2025-01-26", "2025-03-14", "2025-08-15", "2025-10-02",
                "2025-10-21", "2025-10-22", "2025-11-05", "2025-12-25"
            ],
            'api_key': 'xpft4r4qmsoq0p9b',
            'api_secret': '6c96tog8pgp8wiqti9ox7b7nx4hej8g9',
            'telegram_token': '7913084624:AAGvk9-R9YEUf4FGHCwDyOOpGHZOKUHr0mE',
            'chat_id': '1639045622',
            'position_size': 100,
            'lot_size': 20
        }
        
        try:
            with open(self.config_path, 'r') as f:
                config = json.load(f)
            
            # Merge with defaults
            for key, value in defaults.items():
                if key not in config:
                    config[key] = value
            
            return config
            
        except Exception as e:
            logging.error(f"Config loading error: {e}")
            return defaults
    
    def get(self, key: str, default=None):
        """Get configuration value"""
        return self.config.get(key, default)
    
    def update(self, key: str, value: Any):
        """Update configuration value"""
        self.config[key] = value


class TokenManager:
    """Centralized token management to prevent race conditions"""
    
    def __init__(self):
        self.token_file = 'latest_token.txt'
        self.lock = threading.Lock()
        self.logger = logging.getLogger(__name__)
        self.ist_tz = pytz.timezone('Asia/Kolkata')
    
    def save_token(self, token: str, source: str = "unknown") -> bool:
        """Thread-safe token saving"""
        with self.lock:
            try:
                with open(self.token_file, 'w') as f:
                    f.write(token)
                
                # Save metadata
                metadata = {
                    'token': token,
                    'source': source,
                    'timestamp': datetime.now(self.ist_tz).isoformat(),
                    'created_at': time.time()
                }
                
                with open(f"{self.token_file}.meta", 'w') as f:
                    json.dump(metadata, f)
                
                self.logger.info(f"Token saved from source: {source}")
                return True
                
            except Exception as e:
                self.logger.error(f"Failed to save token: {e}")
                return False
    
    def load_token(self) -> Optional[str]:
        """Thread-safe token loading"""
        with self.lock:
            try:
                if os.path.exists(self.token_file):
                    with open(self.token_file, 'r') as f:
                        token = f.read().strip()
                    if token:
                        return token
            except Exception as e:
                self.logger.error(f"Failed to load token: {e}")
            return None
    
    def get_token_metadata(self) -> Dict:
        """Get token metadata"""
        try:
            if os.path.exists(f"{self.token_file}.meta"):
                with open(f"{self.token_file}.meta", 'r') as f:
                    return json.load(f)
        except:
            pass
        
        # Fallback to file stats
        if os.path.exists(self.token_file):
            stat = os.stat(self.token_file)
            return {
                'token': self.load_token(),
                'source': 'file_system',
                'timestamp': datetime.fromtimestamp(stat.st_mtime).isoformat(),
                'created_at': stat.st_mtime
            }
        
        return {}
    
    def is_token_valid(self, max_age_hours: int = 8) -> bool:
        """Check if token is still valid based on age"""
        metadata = self.get_token_metadata()
        if not metadata or not metadata.get('token'):
            return False
        
        created_at = metadata.get('created_at', 0)
        age_seconds = time.time() - created_at
        max_age_seconds = max_age_hours * 3600
        
        return age_seconds < max_age_seconds
    
    def get_token_age_string(self) -> str:
        """Get human-readable token age"""
        metadata = self.get_token_metadata()
        if not metadata.get('created_at'):
            return "Unknown age"
        
        age_seconds = time.time() - metadata['created_at']
        hours = int(age_seconds / 3600)
        minutes = int((age_seconds % 3600) / 60)
        
        if hours > 0:
            return f"{hours}h {minutes}m old"
        else:
            return f"{minutes}m old"
    
    def clear_token(self):
        """Clear token and metadata"""
        with self.lock:
            try:
                for file in [self.token_file, f"{self.token_file}.meta"]:
                    if os.path.exists(file):
                        os.remove(file)
                self.logger.info("Token cleared")
            except Exception as e:
                self.logger.error(f"Failed to clear token: {e}")


class MarketHoursValidator:
    """Validates market hours and trading days"""
    
    def __init__(self, config_manager: ConfigurationManager):
        self.config = config_manager
        self.ist_tz = pytz.timezone('Asia/Kolkata')
    
    def get_market_status(self, allow_pre_market: bool = False) -> MarketStatus:
        """Get comprehensive market status"""
        now = datetime.now(self.ist_tz)
        
        # Check if it's a trading day
        is_trading_day = self._is_trading_day(now)
        if not is_trading_day:
            return MarketStatus(
                is_trading_day=False,
                is_trading_hours=False,
                status_message=self._get_non_trading_day_message(now),
                current_time=now
            )
        
        # Check trading hours
        is_trading_hours, hours_message = self._check_trading_hours(now, allow_pre_market)
        
        return MarketStatus(
            is_trading_day=True,
            is_trading_hours=is_trading_hours,
            status_message=hours_message,
            current_time=now
        )
    
    def _is_trading_day(self, date: datetime) -> bool:
        """Check if given date is a trading day"""
        if date.weekday() >= 5:  # Saturday or Sunday
            return False
        
        date_str = date.strftime("%Y-%m-%d")
        holidays = self.config.get('market_holidays', [])
        return date_str not in holidays
    
    def _check_trading_hours(self, now: datetime, allow_pre_market: bool = False) -> Tuple[bool, str]:
        """Check if current time is within trading hours"""
        market_open = now.replace(hour=9, minute=15, second=0, microsecond=0)
        market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)
        
        # Allow pre-market for authentication (9:00 AM onwards)
        if allow_pre_market:
            pre_market = now.replace(hour=9, minute=0, second=0, microsecond=0)
            if now >= pre_market and now <= market_close:
                if now < market_open:
                    return True, f"Pre-market hours. Market opens at 9:15 AM IST. Current: {now.strftime('%H:%M IST')}"
                else:
                    return True, f"Trading hours active. Current: {now.strftime('%H:%M IST')}"
        else:
            if now >= market_open and now <= market_close:
                return True, f"Trading hours active. Current: {now.strftime('%H:%M IST')}"
        
        if now < market_open:
            return False, f"Market opens at 9:15 AM IST. Current: {now.strftime('%H:%M IST')}"
        else:
            return False, f"Market closed at 3:30 PM IST. Current: {now.strftime('%H:%M IST')}"
    
    def _get_non_trading_day_message(self, date: datetime) -> str:
        """Get message for non-trading days"""
        if date.weekday() >= 5:
            return f"Weekend - Markets closed ({date.strftime('%A')})"
        
        date_str = date.strftime("%Y-%m-%d")
        return f"Market holiday: {date_str}"


class NotificationService(ABC):
    """Abstract notification service"""
    
    @abstractmethod
    def send_message(self, message: str) -> bool:
        pass


class TelegramNotifier(NotificationService):
    """Telegram notification implementation"""
    
    def __init__(self, config_manager: ConfigurationManager):
        self.config = config_manager
        self.logger = logging.getLogger(__name__)
        self.send_lock = threading.Lock()
    
    def send_message(self, message: str) -> bool:
        """Send message via Telegram with deduplication"""
        with self.send_lock:
            try:
                url = f"https://api.telegram.org/bot{self.config.get('telegram_token')}/sendMessage"
                
                # Truncate if too long
                if len(message) > 4000:
                    message = message[:3950] + "\n\n[Message truncated]"
                
                data = {
                    "chat_id": self.config.get('chat_id'),
                    "text": message,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                response = requests.post(url, data=data, timeout=10)
                if response.status_code == 200:
                    self.logger.info("Telegram message sent")
                    return True
                self.logger.error(f"Telegram API error: {response.status_code}")
                return False
            except Exception as e:
                self.logger.error(f"Failed to send Telegram message: {e}")
                return False


class ZerodhaErrorHandler:
    """Handles Zerodha API errors"""
    
    def __init__(self, notifier: NotificationService):
        self.notifier = notifier
        self.logger = logging.getLogger(__name__)
        self.ist_tz = pytz.timezone('Asia/Kolkata')
    
    def handle_error(self, error: Exception, operation: str) -> bool:
        """Handle Zerodha API errors with notifications"""
        ist_time = datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")
        error_type = type(error).__name__
        error_message = str(error)
        
        message = f"""
🔴 <b>Zerodha {error_type}</b>
📅 Time: {ist_time}
🔧 Operation: {operation}
❌ Error: {error_message[:200]}
🔄 Action: Check logs and retry
        """
        
        self.notifier.send_message(message)
        self.logger.error(f"Zerodha {error_type} during {operation}: {error_message}")
        return False


class PostbackHealthMonitor:
    """Monitors postback server health"""
    
    def __init__(self, config_manager: ConfigurationManager):
        self.config = config_manager
        self.logger = logging.getLogger(__name__)
    
    def get_server_urls(self) -> List[str]:
        """Get server API URLs"""
        host = self.config.get('server_host', 'sensexbot.ddns.net')
        if self.config.get('use_https', True):
            return [f"https://{host}", f"http://{host}:8001"]
        return [f"http://{host}:8001"]
    
    def test_server_connection(self, base_url: str) -> bool:
        """Test server connection"""
        try:
            response = requests.get(f"{base_url}/health", timeout=5, verify=False)
            return response.status_code == 200
        except:
            return False
    
    def get_working_server_url(self) -> Optional[str]:
        """Find a working server URL"""
        for url in self.get_server_urls():
            if self.test_server_connection(url):
                self.logger.info(f"Using server: {url}")
                return url
        return None
    
    def check_postback_server(self) -> bool:
        """Check if postback server is running"""
        server_url = self.get_working_server_url()
        if not server_url:
            self.logger.error("No postback server responding")
            return False
        
        try:
            response = requests.get(f"{server_url}/status", timeout=10, verify=False)
            if response.status_code == 200:
                self.logger.info(f"Postback server running: {response.json().get('server')}")
                return True
            return False
        except Exception as e:
            self.logger.error(f"Cannot connect to postback server: {e}")
            return False


class SafeAPIWrapper:
    """Wrapper for safe API calls with error handling"""
    
    def __init__(self, error_handler: ZerodhaErrorHandler):
        self.error_handler = error_handler
    
    def safe_call(self, operation_name: str, operation_func, *args, **kwargs) -> Tuple[Any, bool]:
        """Wrapper for safe Zerodha API calls"""
        try:
            result = operation_func(*args, **kwargs)
            return result, True
        except (NetworkException, TokenException, PermissionException, 
                OrderException, InputException, DataException, GeneralException) as e:
            return None, self.error_handler.handle_error(e, operation_name)
        except Exception as e:
            logging.error(f"Unexpected error in {operation_name}: {e}")
            return None, False


class AuthenticationService:
    """Handles authentication flow with race condition prevention"""
    
    def __init__(self, config_manager: ConfigurationManager, 
                 market_validator: MarketHoursValidator,
                 postback_monitor: PostbackHealthMonitor,
                 notifier: NotificationService,
                 api_wrapper: SafeAPIWrapper,
                 token_manager: TokenManager):
        self.config = config_manager
        self.market_validator = market_validator
        self.postback_monitor = postback_monitor
        self.notifier = notifier
        self.api_wrapper = api_wrapper
        self.token_manager = token_manager
        self.logger = logging.getLogger(__name__)
        self.ist_tz = pytz.timezone('Asia/Kolkata')
        self.auth_lock = threading.Lock()
        self.auth_in_progress = False
    
    def authenticate(self, mode: AuthenticationMode, force: bool = False) -> AuthenticationResult:
        """Main authentication method with race condition protection"""
        with self.auth_lock:
            if self.auth_in_progress:
                self.logger.warning("Authentication already in progress, skipping")
                return AuthenticationResult(success=False, error_message="Authentication in progress")
            
            self.auth_in_progress = True
        
        try:
            return self._perform_authentication_internal(mode, force)
        finally:
            with self.auth_lock:
                self.auth_in_progress = False
    
    def _perform_authentication_internal(self, mode: AuthenticationMode, force: bool = False) -> AuthenticationResult:
        """Internal authentication method"""
        try:
            # Check if we already have a valid token
            if self.token_manager.is_token_valid() and not force:
                existing_token = self.token_manager.load_token()
                if existing_token:
                    self.logger.info("Using existing valid token")
                    return AuthenticationResult(
                        success=True, 
                        token=existing_token, 
                        source="existing_token"
                    )
            
            # Check market status (allow pre-market for authentication)
            market_status = self.market_validator.get_market_status(allow_pre_market=True)
            
            if not market_status.is_trading_day and mode != AuthenticationMode.SCHEDULED and not force:
                error_msg = f"Authentication not allowed: {market_status.status_message}"
                self._send_auth_not_allowed_message(market_status, force)
                return AuthenticationResult(success=False, error_message=error_msg)
            
            # Check postback server
            if not self.postback_monitor.check_postback_server():
                self._send_postback_error_message()
                return AuthenticationResult(success=False, error_message="Postback server error")
            
            # Start authentication flow
            self.logger.info(f"Starting HTTPS authentication (mode: {mode.value})")
            return self._perform_authentication(mode, market_status)
            
        except Exception as e:
            self.logger.error(f"Authentication error: {e}")
            self._send_auth_error_message(str(e))
            return AuthenticationResult(success=False, error_message=str(e))
    
    def _perform_authentication(self, mode: AuthenticationMode, market_status: MarketStatus) -> AuthenticationResult:
        """Perform the actual authentication"""
        # Clear existing tokens
        self.token_manager.clear_token()
        server_url = self.postback_monitor.get_working_server_url()
        if server_url:
            try:
                requests.get(f"{server_url}/clear_token", timeout=5, verify=False)
                self.logger.info("Cleared existing tokens on server")
            except Exception as e:
                self.logger.warning(f"Failed to clear server tokens: {e}")
        
        # Generate auth URL
        postback_url = self.config.get('postback_urls')['primary']
        auth_url = (f"https://kite.zerodha.com/connect/login?"
                   f"api_key={self.config.get('api_key')}&v=3&postback_url={postback_url}")
        
        # Send authentication link
        self._send_auth_link_message(auth_url, mode, market_status)
        
        # Wait for postback response
        request_token = self._wait_for_pstback_response()
        if not request_token:
            return AuthenticationResult(success=False, error_message="No postback response")
        
        # Exchange token
        return self._exchange_token(request_token, mode)
    
    def _wait_for_postback_response(self) -> Optional[str]:
        """Wait for postback response from server"""
        timeout = self.config.get('auth_timeout_seconds', 300)
        start_time = time.time()
        server_url = self.postback_monitor.get_working_server_url()
        
        if not server_url:
            self._send_server_connection_error()
            return None
        
        self.logger.info(f"Waiting for postback response (timeout: {timeout}s)")
        
        while (time.time() - start_time) < timeout:
            try:
                response = requests.get(f"{server_url}/get_token", timeout=5, verify=False)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('status') == 'success' and 'request_token' in data:
                        self.logger.info(f"Received request token via {server_url}")
                        return data['request_token']
                
                # Check if we got access token directly
                response = requests.get(f"{server_url}/get_access_token", timeout=5, verify=False)
                if response.status_code == 200:
                    data = response.json()
                    if data.get('status') == 'success' and 'access_token' in data:
                        self.logger.info("Received access token directly from server")
                        access_token = data['access_token']
                        self.token_manager.save_token(access_token, "postback_server")
                        return "DIRECT_ACCESS_TOKEN"
                
                time.sleep(3)
                
            except Exception as e:
                self.logger.warning(f"Postback check failed: {e}")
                time.sleep(3)
        
        self._send_auth_timeout_message(timeout)
        return None
    
    def _exchange_token(self, request_token: str, mode: AuthenticationMode) -> AuthenticationResult:
        """Exchange request token for access token"""
        # Check if we got an access token directly
        if request_token == "DIRECT_ACCESS_TOKEN":
            access_token = self.token_manager.load_token()
            if access_token:
                self._send_auth_success_message(access_token, "postback_server")
                return AuthenticationResult(
                    success=True, 
                    token=access_token, 
                    source="postback_server"
                )
        
        # Skip token exchange if KiteConnect not available
        if KiteConnect is None:
            self.logger.error("KiteConnect not available for token exchange")
            return AuthenticationResult(success=False, error_message="KiteConnect not available")
        
        # Normal token exchange process
        kite = KiteConnect(api_key=self.config.get('api_key'))
        data, success = self.api_wrapper.safe_call(
            "Token Exchange",
            kite.generate_session,
            request_token=request_token,
            api_secret=self.config.get('api_secret')
        )
        
        if not success or not data:
            return AuthenticationResult(success=False, error_message="Token exchange failed")
        
        access_token = data["access_token"]
        
        # Save token with source information
        self.token_manager.save_token(access_token, f"token_exchange_{mode.value}")
        
        self._send_auth_success_message(access_token, "token_exchange")
        return AuthenticationResult(success=True, token=access_token, source="token_exchange")
    
    def _send_auth_not_allowed_message(self, market_status: MarketStatus, force: bool):
        """Send authentication not allowed message"""
        message = f"""
❌ <b>Authentication Not Allowed</b>
📅 Time: {market_status.current_time.strftime('%Y-%m-%d %H:%M:%S IST')}
⏰ Status: {market_status.status_message}
🕘 Available: Mon-Fri, 9:00 AM - 3:30 PM IST
{'🔄 Use --force to override' if not force else ''}
        """
        self.notifier.send_message(message)
    
    def _send_postback_error_message(self):
        """Send postback server error message"""
        message = f"""
❌ <b>Postback Server Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
🔧 Issue: Postback server not running
📋 Actions:
1. Check server: <code>sudo systemctl status postback</code>
2. Restart: <code>sudo systemctl restart postback</code>
        """
        self.notifier.send_message(message)
    
    def _send_auth_link_message(self, auth_url: str, mode: AuthenticationMode, market_status: MarketStatus):
        """Send authentication link message"""
        message = f"""
🔐 <b>Zerodha Authentication Required</b>
📅 Time: {market_status.current_time.strftime('%Y-%m-%d %H:%M:%S IST')}
🤖 Mode: {mode.value.upper()}
⏰ Market: {market_status.status_message}
🔗 <b>Login:</b> {auth_url}
⏱️ Complete login within 5 minutes
        """
        self.notifier.send_message(message)
    
    def _send_server_connection_error(self):
        """Send server connection error message"""
        message = f"""
❌ <b>Server Connection Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
🔧 Issue: No response from postback server
        """
        self.notifier.send_message(message)
    
    def _send_auth_timeout_message(self, timeout: int):
        """Send authentication timeout message"""
        message = f"""
⏰ <b>Authentication Timeout</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
❌ No response after {timeout} seconds
🔄 Retry with /login
        """
        self.notifier.send_message(message)
    
    def _send_auth_success_message(self, access_token: str, source: str):
        """Send authentication success message"""
        message = f"""
✅ <b>Authentication Successful</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
🔑 Token: {access_token[:20]}...
🔧 Source: {source}
💾 Saved to: latest_token.txt
🚀 Ready for trading
        """
        self.notifier.send_message(message)
    
    def _send_auth_error_message(self, error: str):
        """Send authentication error message"""
        message = f"""
❌ <b>Authentication Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
❌ Error: {error[:200]}
🔄 Retry: /login
        """
        self.notifier.send_message(message)


class TradingBotManager:
    """Manages trading bot lifecycle"""
    
    def __init__(self, config_manager: ConfigurationManager, notifier: NotificationService):
        self.config = config_manager
        self.notifier = notifier
        self.logger = logging.getLogger(__name__)
        self.trading_bot = None
    
    def initialize_bot(self, access_token: str, expiry_date: str) -> bool:
        """Initialize trading bot"""
        try:
            if not access_token:
                self.logger.error("No access token available")
                return False
            
            if SensexTradingBot is None:
                self.logger.error("SensexTradingBot not available")
                return False
            
            self.trading_bot = SensexTradingBot(
                config_file='config.json', 
                expiry_date=expiry_date
            )
            
            if not self.trading_bot.initialize_kite(access_token):
                return False
            
            self.logger.info("SensexTradingBot initialized")
            return True
            
        except Exception as e:
            self.logger.error(f"Error initializing trading bot: {e}")
            return False
    
    def start_trading(self, mode: TradingMode, data_dir: str):
        """Start trading in specified mode"""
        if not self.trading_bot:
            raise ValueError("Trading bot not initialized")
        
        trading_thread = threading.Thread(
            target=self.trading_bot.start_trading,
            args=(mode.value, data_dir),
            daemon=True
        )
        trading_thread.start()
        
        self.logger.info(f"Trading bot started in {mode.value} mode")
        return trading_thread
    
    def stop_trading(self):
        """Stop trading bot"""
        if self.trading_bot:
            self.trading_bot.stop_trading()


class SchedulingService:
    """Handles task scheduling"""
    
    def __init__(self, auth_service: AuthenticationService, 
                 trading_manager: TradingBotManager,
                 market_validator: MarketHoursValidator,
                 notifier: NotificationService,
                 expiry_date: str, data_dir: str):
        self.auth_service = auth_service
        self.trading_manager = trading_manager
        self.market_validator = market_validator
        self.notifier = notifier
        self.expiry_date = expiry_date
        self.data_dir = data_dir
        self.logger = logging.getLogger(__name__)
        self.ist_tz = pytz.timezone('Asia/Kolkata')
        self.is_running = False
    
    def schedule_daily_authentication(self):
        """Schedule daily authentication only for trading days"""
        def daily_auth_job():
            ist_now = datetime.now(self.ist_tz)
            self.logger.info(f"Scheduled authentication check at {ist_now.strftime('%H:%M:%S IST')}")
            
            market_status = self.market_validator.get_market_status(allow_pre_market=True)
            if not market_status.is_trading_day:
                self.logger.warning(f"Scheduled job ran on non-trading day: {market_status.status_message}")
                return
            
            result = self.auth_service.authenticate(AuthenticationMode.SCHEDULED)
            if result.success:
                self.logger.info("Daily authentication completed")
                self._start_trading_bot(result.token)
            else:
                self.logger.error("Daily authentication failed")
        
        for day in ['monday', 'tuesday', 'wednesday', 'thursday', 'friday']:
            getattr(schedule.every(), day).at("09:00").do(
                self._conditional_auth_job, daily_auth_job
            ).tag('auth')
        
        self.logger.info("Scheduled daily authentication for 9:00 AM IST on trading days")
        
        def run_scheduler():
            self.is_running = True
            while self.is_running:
                schedule.run_pending()
                time.sleep(60)
        
        scheduler_thread = threading.Thread(target=run_scheduler, daemon=True)
        scheduler_thread.start()
        return scheduler_thread
    
    def _conditional_auth_job(self, job_func):
        """Only run the job if today is actually a trading day"""
        market_status = self.market_validator.get_market_status(allow_pre_market=True)
        if market_status.is_trading_day:
            job_func()
        else:
            self.logger.info(f"Skipping authentication - {market_status.status_message}")
    
    def _start_trading_bot(self, access_token: str):
        """Start trading bot after authentication"""
        if self.trading_manager.initialize_bot(access_token, self.expiry_date):
            self.trading_manager.start_trading(TradingMode.TEST, self.data_dir)
    
    def stop_scheduling(self):
        """Stop the scheduling service"""
        self.is_running = False
        schedule.clear('auth')


class TelegramBotHandler:
    """Integrated Telegram Bot Handler for Trading System Commands"""
    
    def __init__(self, config, trading_runner, notifier: TelegramNotifier):
        self.config = config
        self.trading_runner = trading_runner
        self.notifier = notifier  # Use TelegramNotifier for all messages
        self.telegram_token = config.get('telegram_token')
        self.chat_id = config.get('chat_id')
        self.ist_tz = pytz.timezone('Asia/Kolkata')
        self.last_update_id = 0
        self.running = False
        self.logger = logging.getLogger(__name__)
        
        # Validate configuration
        if not self.telegram_token:
            raise ValueError("Missing telegram_token in config")
        if not self.chat_id:
            raise ValueError("Missing chat_id in config")
    
    def is_trading_day_and_hours(self):
        """Check if it's a trading day and within trading hours using orchestrator"""
        try:
            market_status = self.trading_runner.get_market_status(allow_pre_market=False)
            
            if not market_status.is_trading_day:
                return False, market_status.status_message
            
            if not market_status.is_trading_hours:
                return False, market_status.status_message
            
            return True, market_status.status_message
            
        except Exception as e:
            self.logger.error(f"Error checking trading hours: {e}")
            return False, f"Unable to verify trading hours: {e}"
    
    def send_telegram_message(self, message):
        """Send message via Telegram using TelegramNotifier"""
        return self.notifier.send_message(message)
    
    def get_system_resources(self):
        """Get system resource information safely"""
        try:
            import psutil
            return {
                'cpu_percent': psutil.cpu_percent(interval=1),
                'memory': psutil.virtual_memory(),
                'disk': psutil.disk_usage('/'),
                'uptime': self._get_system_uptime(),
                'available': True
            }
        except ImportError:
            self.logger.warning("psutil not available for system resource monitoring")
            return {'available': False}
        except Exception as e:
            self.logger.error(f"Error getting system resources: {e}")
            return {'available': False, 'error': str(e)}
    
    def _get_system_uptime(self):
        """Get system uptime safely"""
        try:
            import psutil
            uptime_seconds = time.time() - psutil.boot_time()
            days = int(uptime_seconds // 86400)
            hours = int((uptime_seconds % 86400) // 3600)
            return f"{days}d {hours}h"
        except:
            return "Unknown"
    
    def check_network_connectivity(self):
        """Check network connectivity to important endpoints"""
        connectivity = {}
        
        # Check Zerodha API
        try:
            response = requests.get('https://api.zerodha.com', timeout=5)
            connectivity['zerodha_api'] = {
                'status': 'Online' if response.status_code == 200 else f'Status {response.status_code}',
                'reachable': response.status_code == 200
            }
        except Exception:
            connectivity['zerodha_api'] = {
                'status': 'Unreachable',
                'reachable': False
            }
        
        # Check postback server
        try:
            server_url = self.trading_runner.get_postback_server_url()
            if server_url:
                response = requests.get(f"{server_url}/health", timeout=5, verify=False)
                connectivity['postback_server'] = {
                    'status': 'Online' if response.status_code == 200 else f'Status {response.status_code}',
                    'reachable': response.status_code == 200,
                    'url': server_url
                }
            else:
                connectivity['postback_server'] = {
                    'status': 'Not Found',
                    'reachable': False,
                    'url': None
                }
        except Exception:
            connectivity['postback_server'] = {
                'status': 'Unreachable',
                'reachable': False,
                'url': server_url if 'server_url' in locals() else None
            }
        
        return connectivity
    
    def handle_health_command(self):
        """Handle /health command using orchestrator's comprehensive health check"""
        try:
            ist_time = datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")
            
            # Use orchestrator's health report
            try:
                health_report = self.trading_runner.get_health_report()
            except Exception as e:
                self.logger.error(f"Error getting health report: {e}")
                self.send_telegram_message(f"""
❌ <b>Health Check Error</b>
📅 Time: {ist_time}
❌ Error: Failed to get health report
Details: {str(e)[:200]}
Try /status for basic information.
                """)
                return
            
            # Get additional system information
            system_resources = self.get_system_resources()
            network_status = self.check_network_connectivity()
            
            # Format the comprehensive health message
            health_message = f"""
🏥 <b>System Health Report</b>
📅 Time: {ist_time}
<b>📊 Postback Server:</b>
Status: {'Online' if health_report['postback_server']['status'] == 'Online' else 'Offline'}
URL: {health_report['postback_server']['url'] or 'Not available'}
Reachable: {'Yes' if health_report['postback_server']['reachable'] else 'No'}
<b>📈 Market Status:</b>
Trading Day: {'Yes' if health_report['market']['is_trading_day'] else 'No'}
Trading Hours: {'Active' if health_report['market']['is_trading_hours'] else 'Closed'}
Status: {health_report['market']['status_message']}
<b>🔑 Authentication:</b>
Valid Token: {'Yes' if health_report['authentication']['has_valid_token'] else 'No'}
Token Preview: {health_report['authentication']['token_preview'] or 'None'}
Token Age: {health_report['authentication']['token_age'] if 'token_age' in health_report['authentication'] else 'Unknown'}
Needs Refresh: {'Yes' if health_report['authentication']['needs_refresh'] else 'No'}
<b>🤖 Trading Bot:</b>
Initialized: {'Yes' if health_report['trading_bot']['initialized'] else 'No'}
Ready: {'Ready' if health_report['trading_bot']['ready'] else 'Not Ready'}
<b>📡 Telegram Bot:</b>
Running: {'Yes' if health_report['telegram_bot']['running'] else 'No'}
<b>⚙️ Configuration:</b>
Expiry Date: {health_report['configuration']['expiry_date']}
Data Directory: {health_report['configuration']['data_directory']}
Holidays Configured: {health_report['configuration']['holidays_count']}
Next Holiday: {health_report['configuration']['next_holiday'] or 'None upcoming'}
"""
            
            # Add system resources if available
            if system_resources.get('available'):
                memory = system_resources['memory']
                disk = system_resources['disk']
                health_message += f"""
<b>💻 System Resources:</b>
CPU: {system_resources['cpu_percent']:.1f}%
Memory: {memory.percent:.1f}% ({memory.used//1024//1024//1024:.1f}GB/{memory.total//1024//1024//1024:.1f}GB)
Disk: {disk.percent:.1f}% ({disk.free//1024//1024//1024:.1f}GB free)
Uptime: {system_resources['uptime']}
"""
            else:
                health_message += """
<b>💻 System Resources:</b>
Monitoring not available (install psutil)
"""
            
            # Add network connectivity
            health_message += f"""
<b>🌐 Network Connectivity:</b>
Zerodha API: {network_status['zerodha_api']['status']}
Postback Server: {network_status['postback_server']['status']}
"""
            
            # Health assessment with issue detection
            critical_issues = []
            warnings = []
            
            # Check system resources
            if system_resources.get('available'):
                cpu = system_resources['cpu_percent']
                memory = system_resources['memory']
                disk = system_resources['disk']
                
                if cpu > 80:
                    critical_issues.append("High CPU usage")
                elif cpu > 60:
                    warnings.append("Elevated CPU usage")
                
                if memory.percent > 85:
                    critical_issues.append("High memory usage")
                elif memory.percent > 70:
                    warnings.append("Elevated memory usage")
                
                if disk.percent > 90:
                    critical_issues.append("Low disk space")
                elif disk.percent > 80:
                    warnings.append("Limited disk space")
            
            # Check server status
            if not health_report['postback_server']['reachable']:
                critical_issues.append("Postback server down")
            
            # Check authentication
            if not health_report['authentication']['has_valid_token']:
                if health_report['market']['is_trading_hours']:
                    critical_issues.append("No valid authentication token during trading hours")
                else:
                    warnings.append("Authentication token needed for trading")
            elif health_report['authentication']['needs_refresh']:
                warnings.append("Authentication token may need refresh")
            
            # Check network
            if not network_status['zerodha_api']['reachable']:
                warnings.append("Zerodha API connectivity issues")
            
            # Overall health status
            health_message += f"""
<b>📊 Overall Status:</b>
"""
            
            if critical_issues:
                health_message += f"CRITICAL - {len(critical_issues)} issue(s)\n"
                for issue in critical_issues[:3]:
                    health_message += f"• {issue}\n"
            elif warnings:
                health_message += f"WARNING - {len(warnings)} concern(s)\n"
                for warning in warnings[:3]:
                    health_message += f"• {warning}\n"
            else:
                health_message += "HEALTHY - All systems operational\n"
            
            # Add action recommendations
            if critical_issues or warnings:
                health_message += f"""
<b>🔧 Recommended Actions:</b>
"""
                if not health_report['postback_server']['reachable']:
                    health_message += "• Restart postback server\n"
                if not health_report['authentication']['has_valid_token'] and health_report['market']['is_trading_hours']:
                    health_message += "• Run /login to authenticate\n"
                if not network_status['zerodha_api']['reachable']:
                    health_message += "• Check internet connectivity\n"
            
            health_message += f"""
<b>🔄 Available Commands:</b>
/status - Quick status check
/login - Authentication (market hours only)
/health - This comprehensive report
/help - All commands
"""
            
            self.send_telegram_message(health_message)
            
        except Exception as e:
            error_message = f"""
❌ <b>Health Command Error</b>
📅 Time: {ist_time}
❌ Error: {str(e)[:200]}
Stack: {traceback.format_exc()[-200:]}
Try /status for basic information.
            """
            self.send_telegram_message(error_message)
            self.logger.error(f"Health command error: {e}")
            self.logger.error(traceback.format_exc())
    
    def handle_login_command(self):
        """Handle /login command"""
        try:
            ist_time = datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")
            
            # Check if it's trading hours using orchestrator
            is_trading, trading_status = self.is_trading_day_and_hours()
            
            if not is_trading:
                response_message = f"""
❌ <b>Login Not Available</b>
📅 Time: {ist_time}
⏰ Status: {trading_status}
<b>🕘 Trading Hours:</b>
Monday to Friday: 9:15 AM - 3:30 PM IST
<b>🔄 Available Commands:</b>
/status - Check system status
/health - Comprehensive diagnostics
/help - Show all commands
                """
                self.send_telegram_message(response_message)
                return
            
            # Check if postback server is running
            if not self.trading_runner.check_postback_server():
                error_message = f"""
❌ <b>Login Failed - Server Not Available</b>
📅 Time: {ist_time}
🔧 Issue: HTTPS Postback server not responding
<b>📋 Server Commands:</b>
• Start HTTPS: <code>sudo python3 postback_server.py</code>
• Start HTTP: <code>python3 postback_server.py --http-only</code>
• Check status: <code>curl -k https://sensexbot.ddns.net/status</code>
<b>🔍 Troubleshooting:</b>
1. SSH to AWS instance
2. Run server command
3. Try /login again
                """
                self.send_telegram_message(error_message)
                return
            
            # Initiate authentication
            self.send_telegram_message(f"""
🔄 <b>Manual Login Initiated</b>
📅 Time: {ist_time}
🤖 Mode: Telegram Bot Command
⏰ Status: {trading_status}
🔐 Generating secure authentication link...
⏳ Please wait 5 seconds...
            """)
            
            # Start authentication in background
            auth_thread = threading.Thread(
                target=self._background_authentication, 
                args=('telegram-manual',), 
                daemon=True
            )
            auth_thread.start()
            
        except Exception as e:
            error_message = f"""
❌ <b>Login Command Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
❌ Error: {str(e)[:200]}
Stack: {traceback.format_exc()[-200:]}
Please try again or use manual script:
<code>python3 integrated_e2e_trading_system.py --mode test</code>
            """
            self.send_telegram_message(error_message)
            self.logger.error(f"Login command error: {e}")
            self.logger.error(traceback.format_exc())
    
    def _background_authentication(self, mode):
        """Run authentication in background thread"""
        try:
            access_token = self.trading_runner.get_access_token_via_telegram(mode)
            if access_token:
                success_message = f"""
✅ <b>Telegram Login Successful!</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
🔑 Token: {access_token[:20]}...
🤖 Via: Telegram Bot Command
💾 Saved: latest_token.txt
🚀 <b>System Ready for Trading!</b>
<b>🔄 Next Steps:</b>
• Token valid until market close
• Start trading: <code>python3 integrated_e2e_trading_system.py --mode live</code>
• Check status anytime: /status or /health
                """
                self.send_telegram_message(success_message)
            else:
                failure_message = f"""
❌ <b>Telegram Login Failed</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
⚠️ Authentication did not complete
<b>🔍 Possible Issues:</b>
• Zerodha login timeout (5 min limit)
• Network connectivity problems  
• Server connectivity issues
• Invalid Zerodha credentials
<b>🔄 Retry Options:</b>
• Try /login again
• Manual: <code>python3 integrated_e2e_trading_system.py --mode test</code>
• Check server: <code>curl -k https://sensexbot.ddns.net/status</code>
• Run diagnostics: /health
                """
                self.send_telegram_message(failure_message)
                
        except Exception as e:
            error_message = f"""
❌ <b>Background Authentication Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
❌ Error: {str(e)[:200]}
Stack: {traceback.format_exc()[-200:]}
<b>🔧 Technical Details:</b>
This might be a Zerodha API issue or server problem.
<b>🔄 Manual Recovery:</b>
<code>python3 integrated_e2e_trading_system.py --mode test</code>
            """
            self.send_telegram_message(error_message)
            self.logger.error(f"Background authentication error: {e}")
            self.logger.error(traceback.format_exc())
    
    def handle_status_command(self):
        """Handle /status command using orchestrator's status methods"""
        try:
            ist_time = datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")
            
            # Use orchestrator's detailed status
            try:
                status_data = self.trading_runner.get_detailed_status()
            except Exception as e:
                self.logger.error(f"Error getting detailed status: {e}")
                self.send_telegram_message(f"""
❌ <b>Status Check Error</b>
📅 Time: {ist_time}
❌ Error: Failed to get system status
Details: {str(e)[:200]}
Bot is responding, so basic connectivity works.
Try /health for diagnostics.
                """)
                return
            
            # Format status message
            market_status = status_data['market_status']
            postback = status_data['postback_server']
            auth = status_data['authentication']
            trading_bot = status_data['trading_bot']
            system = status_data['system']
            
            status_message = f"""
📊 <b>Trading System Status</b>
📅 Time: {ist_time}
⏰ Market: {market_status.status_message}
<b>🖥️ Server Status:</b>
HTTPS Server: {'Online' if postback['running'] else 'Offline'}
Host: {postback['host']}
URL: {postback['url'] or 'Not available'}
<b>🔑 Authentication:</b>
Token: {'Valid' if auth['has_token'] else 'No Token'}
Preview: {auth['token_preview'] or 'None'}
Age: {auth['token_age']}
Status: {'May need refresh' if auth['is_expired'] else 'Active'}
<b>📈 Market Info:</b>
Trading Day: {'Yes' if market_status.is_trading_day else 'No'}
Trading Hours: {'Active' if market_status.is_trading_hours else 'Closed'}
Current: {'OPEN' if market_status.is_trading_hours else 'CLOSED'}
<b>🤖 Trading Bot:</b>
Initialized: {'Yes' if trading_bot['initialized'] else 'No'}
<b>⚙️ Configuration:</b>
Expiry Date: {system['expiry_date']}
Data Directory: {system['data_dir']}
Holidays Count: {len(system['holidays'])}
<b>🔄 Available Commands:</b>
/login - Authenticate with Zerodha
/status - This status check
/health - Comprehensive diagnostics
/help - Show all commands
<b>🔧 Manual Commands:</b>
<code>python3 integrated_e2e_trading_system.py --mode test</code>
<code>python3 integrated_e2e_trading_system.py --mode live</code>
            """
            
            self.send_telegram_message(status_message)
            
        except Exception as e:
            error_message = f"""
❌ <b>Status Check Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
❌ Error: {str(e)[:200]}
Stack: {traceback.format_exc()[-200:]}
Basic system appears to be running since you received this message.
Try /health for comprehensive diagnostics.
            """
            self.send_telegram_message(error_message)
            self.logger.error(f"Status command error: {e}")
            self.logger.error(traceback.format_exc())
    
    def handle_help_command(self):
        """Handle /help command"""
        try:
            help_message = f"""
🤖 <b>Trading System Bot Commands</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
<b>🔐 Authentication Commands:</b>
/login - Manual Zerodha authentication
         Only works during market hours
/status - Check system and token status
         Works anytime
/health - Comprehensive system diagnostics
         CPU, memory, disk, network, logs, processes
<b>📈 Market Information:</b>
Trading Hours: Mon-Fri 9:15 AM - 3:30 PM IST
Weekends: Markets closed
Holidays: Automatically detected
<b>🔧 Manual Script Commands:</b>
<code>python3 integrated_e2e_trading_system.py --mode test</code>
<code>python3 integrated_e2e_trading_system.py --mode live</code>
<code>python3 integrated_e2e_trading_system.py --mode setup</code>
<code>python3 integrated_e2e_trading_system.py --mode bot</code>
<b>🖥️ Server Commands:</b>
<code>sudo python3 postback_server.py</code> (HTTPS)
<code>python3 postback_server.py --http-only</code> (HTTP)
<b>🔍 System Endpoints:</b>
HTTPS: https://sensexbot.ddns.net/status
HTTP: http://sensexbot.ddns.net:8001/status
<b>💡 Tips:</b>
• Use /login if you missed 9 AM authentication
• Check /status before starting trading
• Use /health for troubleshooting issues
• Authentication required daily
• Tokens expire at market close
<b>⚠️ Error Recovery:</b>
If bot doesn't respond, use manual script commands on AWS instance.
            """
            self.send_telegram_message(help_message)
        except Exception as e:
            error_message = f"""
❌ <b>Help Command Error</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
❌ Error: {str(e)[:200]}
Stack: {traceback.format_exc()[-200:]}
Basic Commands:
/login - Manual authentication
/status - System status
/health - Full diagnostics
/help - This help
            """
            self.send_telegram_message(error_message)
            self.logger.error(f"Help command error: {e}")
    
    def get_updates(self):
        """Get updates from Telegram Bot API"""
        try:
            url = f"https://api.telegram.org/bot{self.telegram_token}/getUpdates"
            params = {
                "offset": self.last_update_id + 1,
                "timeout": 30
            }
            
            response = requests.get(url, params=params, timeout=35)
            if response.status_code == 200:
                return response.json()
            else:
                self.logger.error(f"Telegram getUpdates error: {response.status_code}")
                return None
                
        except Exception as e:
            self.logger.error(f"Error getting Telegram updates: {e}")
            return None
    
    def process_command(self, message):
        """Process incoming command with better error handling"""
        try:
            text = message.get('text', '').strip().lower()
            chat_id = str(message['chat']['id'])
            username = message.get('from', {}).get('username', 'Unknown')
            
            # Verify chat ID matches configuration
            if chat_id != str(self.chat_id):
                self.logger.warning(f"Unauthorized chat ID: {chat_id} from user: {username}")
                return
            
            self.logger.info(f"Processing command: {text} from user: {username}")
            
            # Command routing
            command_handlers = {
                '/login': self.handle_login_command,
                '/status': self.handle_status_command,
                '/health': self.handle_health_command,
                '/help': self.handle_help_command,
                '/start': self.handle_help_command
            }
            
            handler = command_handlers.get(text)
            if handler:
                handler()
            else:
                # Unknown command
                self.send_telegram_message(f"""
❓ <b>Unknown Command</b>
You sent: <code>{text[:50]}</code>
<b>Available commands:</b>
/login - Authenticate with Zerodha
/status - Check system status
/health - Comprehensive diagnostics
/help - Show all commands
<b>Manual script option:</b>
<code>python3 integrated_e2e_trading_system.py --mode test</code>
                """)
                
        except Exception as e:
            self.logger.error(f"Error processing command: {e}")
            self.logger.error(traceback.format_exc())
            try:
                self.send_telegram_message(f"Error processing command: {str(e)[:100]}")
            except:
                self.logger.error("Failed to send error message to Telegram")
    
    def start_bot(self):
        """Start the Telegram bot listener with better error handling"""
        self.running = True
        self.logger.info("Starting Telegram bot listener...")
        
        # Send startup message
        try:
            startup_message = f"""
🤖 <b>Trading System Bot Started</b>
📅 Time: {datetime.now(self.ist_tz).strftime("%Y-%m-%d %H:%M:%S IST")}
🔄 Status: Listening for commands
<b>Available commands:</b>
/login - Manual authentication
/status - System status
/health - Comprehensive diagnostics
/help - Show all commands
Bot is now monitoring for your commands!
            """
            self.send_telegram_message(startup_message)
        except Exception as e:
            self.logger.error(f"Failed to send startup message: {e}")
        
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while self.running:
            try:
                updates = self.get_updates()
                if updates and updates.get('ok'):
                    for update in updates.get('result', []):
                        self.last_update_id = update['update_id']
                        
                        if 'message' in update:
                            message = update['message']
                            if 'text' in message:
                                self.process_command(message)
                
                # Reset error counter on successful operation
                consecutive_errors = 0
                time.sleep(1)
                
            except KeyboardInterrupt:
                self.logger.info("Bot interrupted by user")
                break
            except Exception as e:
                consecutive_errors += 1
                self.logger.error(f"Bot polling error #{consecutive_errors}: {e}")
                
                if consecutive_errors >= max_consecutive_errors:
                    self.logger.error(f"Too many consecutive errors ({consecutive_errors}), stopping bot")
                    try:
                        self.send_telegram_message(f"""
❌ <b>Bot Stopped Due to Errors</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
❌ Consecutive errors: {consecutive_errors}
🔄 Restart required
Use manual script commands on AWS instance.
                        """)
                    except:
                        pass
                    break
                
                # Exponential backoff for retries
                sleep_time = min(60, 5 * (2 ** consecutive_errors))
                self.logger.info(f"Sleeping {sleep_time} seconds before retry")
                time.sleep(sleep_time)
        
        self.logger.info("Telegram bot stopped")
    
    def stop_bot(self):
        """Stop the Telegram bot listener"""
        self.running = False
        
        # Send shutdown message
        try:
            shutdown_message = f"""
🔴 <b>Trading System Bot Stopped</b>
📅 Time: {datetime.now(self.ist_tz).strftime('%Y-%m-%d %H:%M:%S IST')}
Bot commands are no longer available.
Use manual script commands on AWS instance.
            """
            self.send_telegram_message(shutdown_message)
        except Exception as e:
            self.logger.error(f"Failed to send shutdown message: {e}")


class TelegramBotService:
    """Manages Telegram bot lifecycle"""
    
    def __init__(self, config_manager: ConfigurationManager, system_orchestrator):
        self.config = config_manager
        self.system_orchestrator = system_orchestrator
        self.notifier = TelegramNotifier(config_manager)
        self.telegram_bot = None
        self.bot_thread = None
        self.logger = logging.getLogger(__name__)
    
    def start_bot(self) -> bool:
        """Start Telegram bot"""
        try:
            self.telegram_bot = TelegramBotHandler(self.config.config, self.system_orchestrator, self.notifier)
            self.bot_thread = threading.Thread(target=self.telegram_bot.start_bot, daemon=True)
            self.bot_thread.start()
            self.logger.info("Telegram bot started")
            return True
        except Exception as e:
            self.logger.error(f"Failed to start Telegram bot: {e}")
            return False
    
    def stop_bot(self):
        """Stop Telegram bot"""
        try:
            if self.telegram_bot:
                self.telegram_bot.stop_bot()
            self.logger.info("Telegram bot stopped")
        except Exception as e:
            self.logger.error(f"Error stopping Telegram bot: {e}")


class TradingSystemOrchestrator:
    """High-level system orchestrator with improved token management"""
    
    def __init__(self, expiry_date: str = None, data_dir: str = "option_data"):
        self.logger = logging.getLogger(__name__)
        self.expiry_date = expiry_date or '2025-09-11'
        self.data_dir = data_dir
        self.is_running = False
        
        # Initialize components
        self._initialize_components()
    
    def _initialize_components(self):
        """Initialize all system components"""
        # Core services
        self.config_manager = ConfigurationManager()
        self.market_validator = MarketHoursValidator(self.config_manager)
        self.postback_monitor = PostbackHealthMonitor(self.config_manager)
        self.notifier = TelegramNotifier(self.config_manager)
        self.token_manager = TokenManager()
        
        # Error handling and API wrapper
        self.error_handler = ZerodhaErrorHandler(self.notifier)
        self.api_wrapper = SafeAPIWrapper(self.error_handler)
        
        # Business services
        self.auth_service = AuthenticationService(
            self.config_manager, self.market_validator,
            self.postback_monitor, self.notifier, self.api_wrapper, self.token_manager
        )
        self.trading_manager = TradingBotManager(self.config_manager, self.notifier)
        self.scheduling_service = SchedulingService(
            self.auth_service, self.trading_manager, self.market_validator,
            self.notifier, self.expiry_date, self.data_dir
        )
        
        # UI services
        self.telegram_service = TelegramBotService(self.config_manager, self)
    
    def get_access_token_via_telegram(self, mode: str = "telegram-manual") -> Optional[str]:
        """Telegram bot compatible method for authentication"""
        try:
            self.logger.info(f"Telegram bot initiated authentication: {mode}")
            result = self.auth_service.authenticate(AuthenticationMode.MANUAL, force=False)
            if result.success:
                self.logger.info("Authentication successful via Telegram")
                return result.token
            else:
                self.logger.error(f"Authentication failed: {result.error_message}")
                return None
        except Exception as e:
            self.logger.error(f"Error in get_access_token_via_telegram: {e}")
            return None
    
    def check_postback_server(self) -> bool:
        """Wrapper method for postback server check"""
        return self.postback_monitor.check_postback_server()
    
    def authenticate_manual(self, force: bool = False) -> bool:
        """Public method for manual authentication"""
        result = self.auth_service.authenticate(AuthenticationMode.MANUAL, force)
        return result.success
    
    def get_postback_server_url(self) -> Optional[str]:
        """Get working postback server URL"""
        return self.postback_monitor.get_working_server_url()
    
    def get_market_status(self, allow_pre_market: bool = False) -> MarketStatus:
        """Get current market status"""
        return self.market_validator.get_market_status(allow_pre_market)
    
    def has_valid_token(self) -> bool:
        """Check if system has a valid access token"""
        return self.token_manager.is_token_valid()
    
    def get_token_preview(self) -> Optional[str]:
        """Get preview of current token"""
        token = self.token_manager.load_token()
        if token:
            return token[:20] + '...'
        return None
    
    def get_token_age(self) -> str:
        """Get age of current token"""
        return self.token_manager.get_token_age_string()
    
    def is_token_expired(self) -> bool:
        """Check if token is likely expired"""
        return not self.token_manager.is_token_valid()
    
    def get_system_health(self) -> SystemHealth:
        """Get comprehensive system health for /health command"""
        market_status = self.market_validator.get_market_status()
        postback_status = self.postback_monitor.check_postback_server()
        server_url = self.postback_monitor.get_working_server_url()
        
        return SystemHealth(
            postback_server_running=postback_status,
            postback_server_url=server_url,
            market_status=market_status,
            has_token=self.has_valid_token(),
            token_preview=self.get_token_preview(),
            trading_bot_initialized=bool(self.trading_manager.trading_bot),
            telegram_bot_running=bool(self.telegram_service.telegram_bot and self.telegram_service.telegram_bot.running),
            holidays_configured=self.config_manager.get('market_holidays', [])
        )
    
    def get_detailed_status(self) -> Dict:
        """Get detailed status for Telegram bot /status command"""
        market_status = self.get_market_status()
        server_url = self.get_postback_server_url()
        
        return {
            'market_status': market_status,
            'postback_server': {
                'running': self.check_postback_server(),
                'url': server_url,
                'host': self.config_manager.get('server_host', 'sensexbot.ddns.net')
            },
            'authentication': {
                'has_token': self.has_valid_token(),
                'token_preview': self.get_token_preview(),
                'token_age': self.get_token_age(),
                'is_expired': self.is_token_expired()
            },
            'trading_bot': {
                'initialized': bool(self.trading_manager.trading_bot)
            },
            'system': {
                'expiry_date': self.expiry_date,
                'data_dir': self.data_dir,
                'holidays': self.config_manager.get('market_holidays', [])
            }
        }
    
    def get_health_report(self) -> Dict:
        """Get comprehensive health report for /health command"""
        health = self.get_system_health()
        
        return {
            'timestamp': datetime.now(pytz.timezone('Asia/Kolkata')),
            'postback_server': {
                'status': 'Online' if health.postback_server_running else 'Offline',
                'url': health.postback_server_url,
                'reachable': health.postback_server_running
            },
            'market': {
                'is_trading_day': health.market_status.is_trading_day,
                'is_trading_hours': health.market_status.is_trading_hours,
                'status_message': health.market_status.status_message,
                'current_time': health.market_status.current_time
            },
            'authentication': {
                'has_valid_token': health.has_token,
                'token_preview': health.token_preview,
                'token_age': self.get_token_age(),
                'needs_refresh': self.is_token_expired()
            },
            'trading_bot': {
                'initialized': health.trading_bot_initialized,
                'ready': health.trading_bot_initialized and health.has_token
            },
            'telegram_bot': {
                'running': health.telegram_bot_running
            },
            'configuration': {
                'expiry_date': self.expiry_date,
                'data_directory': self.data_dir,
                'holidays_count': len(health.holidays_configured),
                'next_holiday': self._get_next_holiday(health.holidays_configured)
            }
        }
    
    def _get_next_holiday(self, holidays: List[str]) -> Optional[str]:
        """Get the next upcoming holiday"""
        try:
            today = datetime.now().date()
            future_holidays = [
                datetime.strptime(h, '%Y-%m-%d').date() 
                for h in holidays 
                if datetime.strptime(h, '%Y-%m-%d').date() >= today
            ]
            if future_holidays:
                return min(future_holidays).strftime('%Y-%m-%d')
        except Exception:
            pass
        return None
    
    def authenticate(self, mode: AuthenticationMode = AuthenticationMode.INTERACTIVE, force: bool = False) -> bool:
        """Public method for authentication"""
        result = self.auth_service.authenticate(mode, force)
        return result.success
    
    def start_trading(self, mode: TradingMode) -> bool:
        """Start trading in specified mode"""
        token = self.token_manager.load_token()
        if not token:
            self.logger.error("No access token available for trading")
            return False
        
        if self.trading_manager.initialize_bot(token, self.expiry_date):
            self.trading_manager.start_trading(mode, self.data_dir)
            return True
        return False
    
    def get_system_status(self) -> Dict:
        """Get comprehensive system status"""
        return self.get_detailed_status()
    
    def run_full_setup(self) -> bool:
        """Run complete system setup"""
        try:
            self.logger.info("Starting full system setup")
            # Start Telegram bot
            if not self.telegram_service.start_bot():
                return False
            
            # Schedule authentication
            self.scheduling_service.schedule_daily_authentication()
            
            # Get current holiday list for display
            holidays = self.config_manager.get('market_holidays', [])
            holidays_str = ', '.join(holidays) if holidays else 'None configured'
            
            # Send setup complete message
            self.notifier.send_message(f"""
🛠️ <b>System Setup Complete</b>
📅 Time: {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%Y-%m-%d %H:%M:%S IST')}
📡 Postback Server: {self.postback_monitor.get_working_server_url() or 'Not running'}
📅 Authentication scheduled for 9:00 AM IST on trading days
🎯 Market Holidays: {holidays_str}
🤖 Trading will start in test mode after authentication
🔄 Commands: /login, /status, /health, /help
            """)
            
            self.is_running = True
            return True
            
        except Exception as e:
            self.logger.error(f"Setup error: {e}")
            self.notifier.send_message(f"❌ <b>Setup Error</b>: {str(e)[:200]}")
            return False
    
    def run_bot_only_mode(self) -> bool:
        """Run only Telegram bot for manual commands"""
        success = self.telegram_service.start_bot()
        if success:
            # Send bot-only mode startup message with holiday info
            holidays = self.config_manager.get('market_holidays', [])
            holidays_str = ', '.join(holidays) if holidays else 'None configured'
            
            self.notifier.send_message(f"""
🤖 <b>Telegram Bot Only Mode Started</b>
📅 Time: {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%Y-%m-%d %H:%M:%S IST')}
🎯 Market Holidays: {holidays_str}
🔄 Commands: /login, /status, /health, /help
            """)
            return True
        return False
    
    def stop_system(self):
        """Stop all system components"""
        try:
            self.scheduling_service.stop_scheduling()
            self.trading_manager.stop_trading()
            self.telegram_service.stop_bot()
            self.is_running = False
            self.logger.info("System stopped")
            
            self.notifier.send_message(f"""
🛑 <b>System Stopped</b>
📅 Time: {datetime.now(pytz.timezone('Asia/Kolkata')).strftime('%Y-%m-%d %H:%M:%S IST')}
All services terminated
            """)
        except Exception as e:
            self.logger.error(f"Error stopping system: {e}")


def setup_logging():
    """Configure logging with IST timezone"""
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    
    # Create logs directory if it doesn't exist
    os.makedirs('logs', exist_ok=True)
    
    # File handler with rotation
    file_handler = RotatingFileHandler(
        'logs/trading_system.log',
        maxBytes=5*1024*1024,  # 5MB
        backupCount=5
    )
    
    # Console handler
    console_handler = logging.StreamHandler(sys.stdout)
    
    # Custom formatter with IST
    formatter = ISTFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S IST'
    )
    
    file_handler.setFormatter(formatter)
    console_handler.setFormatter(formatter)
    
    logger.addHandler(file_handler)
    logger.addHandler(console_handler)


def main():
    """Main entry point"""
    setup_logging()
    logger = logging.getLogger(__name__)
    
    parser = argparse.ArgumentParser(description="Integrated Trading System")
    parser.add_argument('--mode', choices=['setup', 'test', 'live', 'bot'], 
                       default='setup', help="Operation mode")
    parser.add_argument('--force', action='store_true', 
                       help="Force authentication even on non-trading days")
    parser.add_argument('--expiry-date', default='2025-09-11',
                       help="Option expiry date (YYYY-MM-DD)")
    parser.add_argument('--data-dir', default='option_data',
                       help="Directory for trading data")
    
    args = parser.parse_args()
    
    try:
        system = TradingSystemOrchestrator(
            expiry_date=args.expiry_date,
            data_dir=args.data_dir
        )
        
        if args.mode == 'setup':
            success = system.run_full_setup()
            if not success:
                logger.error("Full setup failed")
                sys.exit(1)
                
        elif args.mode == 'bot':
            success = system.run_bot_only_mode()
            if not success:
                logger.error("Bot-only mode failed")
                sys.exit(1)
                
        elif args.mode in ['test', 'live']:
            # Authenticate first
            success = system.authenticate(
                mode=AuthenticationMode.MANUAL,
                force=args.force
            )
            if not success:
                logger.error("Authentication failed")
                sys.exit(1)
            
            # Start trading
            mode = TradingMode.TEST if args.mode == 'test' else TradingMode.LIVE
            success = system.start_trading(mode)
            if not success:
                logger.error(f"Failed to start trading in {args.mode} mode")
                sys.exit(1)
        
        # Keep the main thread alive
        try:
            while system.is_running:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("Received shutdown signal")
            system.stop_system()
            
    except Exception as e:
        logger.error(f"Fatal error in main: {e}")
        logger.error(traceback.format_exc())
        system.stop_system()
        sys.exit(1)


if __name__ == "__main__":
    main()
